package com.akosgyongyosi.cashflow.service;

import com.akosgyongyosi.cashflow.entity.*;
import com.akosgyongyosi.cashflow.entity.Currency;
import com.akosgyongyosi.cashflow.repository.CashflowPlanRepository;
import com.akosgyongyosi.cashflow.repository.TransactionRepository;
import com.akosgyongyosi.cashflow.service.fx.FxService;
import com.akosgyongyosi.cashflow.service.fx.FxRequestCache;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;

@Service
public class CashflowPlanService {

    private final CashflowPlanRepository planRepository;
    private final TransactionRepository transactionRepository;
    private final FxService fxService;
    
    public CashflowPlanService(CashflowPlanRepository planRepository,
                               TransactionRepository transactionRepository,
                               FxService fxService) {
        this.planRepository = planRepository;
        this.transactionRepository = transactionRepository;
        this.fxService = fxService;
    }

    public Optional<CashflowPlan> getPlan(Long planId) {
        return planRepository.findById(planId);
    }

    public List<CashflowPlan> findAll() {
        return planRepository.findAll();
    }    

    @Transactional
    public CashflowPlan createPlanForInterval(String planName, LocalDate start, LocalDate end, String groupKey) {
        return doCreatePlan(planName, start, end, ScenarioType.REALISTIC, BigDecimal.ZERO, groupKey, null);
    }

    @Transactional
    public CashflowPlan createPlanForInterval(String planName,
                                              LocalDate start,
                                              LocalDate end,
                                              ScenarioType scenario,
                                              BigDecimal startBalance,
                                              String groupKey) {
        return doCreatePlan(planName, start, end, scenario, startBalance, groupKey, null);
    }

    private CashflowPlan doCreatePlan(String planName,
                                      LocalDate start,
                                      LocalDate end,
                                      ScenarioType scenario,
                                      BigDecimal startBalance,
                                      String groupKey,
                                      Currency baseCurrency) {
        CashflowPlan plan = new CashflowPlan();
        plan.setPlanName(planName);
        plan.setStartDate(start);
        plan.setEndDate(end);
        plan.setDescription("Autogenerated from actuals: " + start + " - " + end);
        plan.setGroupKey(groupKey);
        plan.setScenario(scenario);
        plan.setStartBalance(startBalance);
    plan.setBaselineTransactions(new ArrayList<>());
    Currency effectiveBaseCurrency = (baseCurrency != null) ? baseCurrency : inferBaseCurrency(start, end);
    plan.setBaseCurrency(effectiveBaseCurrency);

    List<Transaction> lastYearTransactions = transactionRepository
        .findByBookingDateBetween(start.minusYears(1), end.minusYears(1));
    FxRequestCache cache = new FxRequestCache(fxService);

    for (Transaction tx : lastYearTransactions) {
        HistoricalTransaction hist = convertTransactionToHistorical(tx, plan, cache);
        plan.getBaselineTransactions().add(hist);
    }

        return planRepository.save(plan);
    }

    @Transactional
    public List<CashflowPlan> createAllScenarioPlans(String basePlanName, LocalDate start, LocalDate end, BigDecimal startBalance, Currency baseCurrency) {
        String groupKey = UUID.randomUUID().toString(); 

    CashflowPlan worst = doCreatePlan(basePlanName + "-WORST", start, end, ScenarioType.WORST, startBalance, groupKey, baseCurrency);
    CashflowPlan real = doCreatePlan(basePlanName + "-REALISTIC", start, end, ScenarioType.REALISTIC, startBalance, groupKey, baseCurrency);
    CashflowPlan best = doCreatePlan(basePlanName + "-BEST", start, end, ScenarioType.BEST, startBalance, groupKey, baseCurrency);

        return List.of(worst, real, best);
    }

    @Transactional(readOnly = true)
    public List<CashflowPlan> findAllByGroupKey(String groupKey) {
        return planRepository.findByGroupKey(groupKey);
    }

    private HistoricalTransaction convertTransactionToHistorical(Transaction tx, CashflowPlan plan, FxRequestCache cache) {
        HistoricalTransaction hist = new HistoricalTransaction();
        hist.setTransactionDate(tx.getBookingDate().plusYears(1));
        // Original details
        hist.setOriginalAmount(tx.getAmount());
        hist.setOriginalCurrency(tx.getCurrency());
        // Convert to plan base currency if needed
        BigDecimal normalized = tx.getCurrency() == plan.getBaseCurrency()
                ? tx.getAmount()
                : cache.convert(tx.getAmount(), tx.getCurrency(), plan.getBaseCurrency(), tx.getBookingDate());
        hist.setAmount(normalized);
        hist.setCategory(tx.getCategory());
        hist.setCashflowPlan(plan);
        hist.setSnapshotDate(LocalDate.now());
        return hist;
    }

    private Currency inferBaseCurrency(LocalDate start, LocalDate end) {
        List<Transaction> lastYear = transactionRepository.findByBookingDateBetween(start.minusYears(1), end.minusYears(1));
        boolean hasHuf = lastYear.stream().anyMatch(t -> t.getCurrency() == Currency.HUF);
        boolean hasEur = lastYear.stream().anyMatch(t -> t.getCurrency() == Currency.EUR);
        if (hasHuf) return Currency.HUF;
        if (hasEur) return Currency.EUR;
        return lastYear.stream().map(Transaction::getCurrency).findFirst().orElse(Currency.HUF);
    }

    @Transactional
    public CashflowPlan regenerateBaseline(Long planId) {
        CashflowPlan plan = planRepository.findById(planId)
                .orElseThrow(() -> new NoSuchElementException("Plan not found: " + planId));
        plan.getBaselineTransactions().clear();
        FxRequestCache cache = new FxRequestCache(fxService);
        List<Transaction> lastYearTransactions = transactionRepository
                .findByBookingDateBetween(plan.getStartDate().minusYears(1), plan.getEndDate().minusYears(1));
        for (Transaction tx : lastYearTransactions) {
            plan.getBaselineTransactions().add(convertTransactionToHistorical(tx, plan, cache));
        }
        return planRepository.save(plan);
    }

    @Transactional
    public boolean deletePlanGroup(String groupKey) {
        List<CashflowPlan> plans = planRepository.findByGroupKey(groupKey);
        if (plans.isEmpty()) {
            return false;
        }
        planRepository.deleteAll(plans);
        return true;
    }
}
