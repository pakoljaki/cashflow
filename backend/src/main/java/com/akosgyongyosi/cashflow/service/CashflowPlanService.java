package com.akosgyongyosi.cashflow.service;

import com.akosgyongyosi.cashflow.entity.CashflowPlan;
import com.akosgyongyosi.cashflow.entity.HistoricalTransaction;
import com.akosgyongyosi.cashflow.entity.ScenarioType;
import com.akosgyongyosi.cashflow.entity.Transaction;
import com.akosgyongyosi.cashflow.repository.CashflowPlanRepository;
import com.akosgyongyosi.cashflow.repository.HistoricalTransactionRepository;
import com.akosgyongyosi.cashflow.repository.TransactionRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class CashflowPlanService {

    private final CashflowPlanRepository planRepository;
    private final TransactionRepository transactionRepository;
    private final HistoricalTransactionRepository historicalTransactionRepository;

    public CashflowPlanService(CashflowPlanRepository planRepository,
                               TransactionRepository transactionRepository,
                               HistoricalTransactionRepository historicalTransactionRepository) {
        this.planRepository = planRepository;
        this.transactionRepository = transactionRepository;
        this.historicalTransactionRepository = historicalTransactionRepository;
    }

    public Optional<CashflowPlan> getPlan(Long planId) {
        return planRepository.findById(planId);
    }

    /**
     * Creates a SINGLE plan for a given scenario with a specified startBalance.
     * Overloaded version of the original method, 
     * letting the caller specify scenario & starting balance.
     */
    @Transactional
    public CashflowPlan createPlanForInterval(String planName,
                                              LocalDate start,
                                              LocalDate end,
                                              ScenarioType scenario,
                                              BigDecimal startBalance) {

        CashflowPlan plan = new CashflowPlan();
        plan.setPlanName(planName);
        plan.setStartDate(start);
        plan.setEndDate(end);
        plan.setDescription("Autogenerated from actuals: " + start + " - " + end);
        plan.setBaselineTransactions(new ArrayList<>());

        // NEW: store which scenario this plan is for
        plan.setScenario(scenario);

        // NEW: store startBalance
        plan.setStartBalance(startBalance);

        // (Same logic as before)
        List<Transaction> lastYearTransactions = transactionRepository
            .findByBookingDateBetween(start.minusYears(1), end.minusYears(1));

        for (Transaction tx : lastYearTransactions) {
            HistoricalTransaction hist = convertTransactionToHistorical(tx, plan);
            plan.getBaselineTransactions().add(hist);
        }

        return planRepository.save(plan);
    }

    /**
     * This method is from your original code, included for reference if you
     * still need a "simple" plan creation. 
     * 
     * If you prefer, you can remove or adapt it to always require scenario & startBalance.
     */
    @Transactional
    public CashflowPlan createPlanForInterval(String planName, LocalDate start, LocalDate end) {
        // Could default to REALISTIC scenario with a zero startBalance, for example
        return createPlanForInterval(planName, start, end, ScenarioType.REALISTIC, BigDecimal.ZERO);
    }

    /**
     * NEW METHOD: Create all three scenario plans (Worst, Realistic, Best).
     * Returns a List of 3 saved plans. 
     * 
     * Example usage: planService.createAllScenarioPlans("MyPlan", start, end, BigDecimal.valueOf(10000));
     */
    @Transactional
    public List<CashflowPlan> createAllScenarioPlans(String basePlanName,
                                                     LocalDate start,
                                                     LocalDate end,
                                                     BigDecimal startBalance) {
        List<CashflowPlan> scenarioPlans = new ArrayList<>();

        // 1) Worst
        CashflowPlan worstPlan = createPlanForInterval(
                basePlanName + "-WORST",
                start,
                end,
                ScenarioType.WORST,
                startBalance
        );
        scenarioPlans.add(worstPlan);

        // 2) Realistic
        CashflowPlan realisticPlan = createPlanForInterval(
                basePlanName + "-REALISTIC",
                start,
                end,
                ScenarioType.REALISTIC,
                startBalance
        );
        scenarioPlans.add(realisticPlan);

        // 3) Best
        CashflowPlan bestPlan = createPlanForInterval(
                basePlanName + "-BEST",
                start,
                end,
                ScenarioType.BEST,
                startBalance
        );
        scenarioPlans.add(bestPlan);

        return scenarioPlans;
    }

    /**
     * Convert a real Transaction from last year into a HistoricalTransaction for our planâ€™s baseline.
     */
    private HistoricalTransaction convertTransactionToHistorical(Transaction tx, CashflowPlan plan) {
        HistoricalTransaction hist = new HistoricalTransaction();
        hist.setTransactionDate(tx.getBookingDate().plusYears(1));
        hist.setAmount(tx.getAmount());
        hist.setCategory(tx.getCategory());
        hist.setCashflowPlan(plan);
        return hist;
    }
}
